# 설계자 검증에서 EEPROM_Memory 시트 체크를 위한 프로그램
import re
import os

import xml.etree.ElementTree as ET
#XML을 보기 좋게 만들어 저장
from xml.dom import minidom
from xml.etree.ElementTree import Element, SubElement, ElementTree, dump
from xml.etree import ElementTree
import uuid
import json


# 보기 좋게 xml 만드는 함수, 줄바꿈, 들여쓰기 작업
def indent(elem, level=0): #자료 출처 https://goo.gl/J8VoDK
    i = "\n" + level*"  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            indent(elem, level+1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i

def testDefinitionFind(FileData, tempTxt, p, listForSearch, reFlag, caseSensFlag):
    findFlag = 0
    blockStartFlag = 0
    blockCount = 0
    tempDict = {}
    commentStartFlag = 0
    for line in FileData.readlines():
        tempLine = line.lstrip()
        if (tempLine.find('/*') == 0) and (tempLine.find('*/') >= 0):  # 주석 시작과 끝이 있을 경우
            continue  # 실행 건너 띄기
        if tempLine.find('/*') == 0:  # 주석 시작 부분이 있다면...
            commentStartFlag = 1
            continue  # 실행 건너 띄기
        if line.find('*/') != -1:  # 주석 끝 부분이 있다면...
            commentStartFlag = 0
            continue  # 실행 건너 띄기
        if (tempLine.find('//') == 0) or (tempLine.find('*') == 0) or (commentStartFlag == 1):
            continue
        count = 0
        for pData in p:
            if ((reFlag == True) and (pData.match(line) != None)) or ((reFlag==False) and (((pData in line)and(caseSensFlag == True))or((pData.upper() in line.upper())and(caseSensFlag==False)))):
                # p.__delitem__(count)
                print("코드 : "+line+ ", 파일 이름 : " + FileData.name.split('\\')[len(FileData.name.split('\\'))-1])  # 라인 출력
                listForSearch[p.index(pData)] = 'o'
                # print(line + ", 파일 이름 : " + str(len(FileData.name.split('\\'))))  # 라인 출력
                tempTxt = tempTxt + line
                count = count + 1
        tempTxt = tempTxt + line
        # print(line)
    return
#FEE_TARGET_PATH = '''\\\\192.168.21.22\\d$\\jckim\\Workspace_odin\\lx2_pe_swp\\lx2_pe_icu\\Configuration\\ECU\\Mcal\\'''
#TARGET_PATH = '''\\\\192.168.21.22\\d$\\jckim\\Workspace_odin\\bn7i_swp\\bn7i_icu_nvm\\Static_Code\\Code'''

FEE_TARGET_PATH = '''\\\\192.168.21.22\\d$\\jckim\\Workspace_odin\\lx2_pe_swp\\on_pe_icu\\Configuration\\ECU\\Mcal\\'''
NvM_TARGET_PATH = '''\\\\192.168.21.22\\d$\\jckim\\Workspace_odin\\lx2_pe_swp\\on_pe_icu\\Configuration\\ECU\\'''
TARGET_PATH = '''\\\\192.168.21.22\\d$\\jckim\\Workspace_odin\\lx2_pe_swp\\on_pe_icu\\Static_Code\\Code'''

regularExEnableFlag = False
caseSensitiveFlag = False
onlyCCodeFlag = False
# 192.168.2.133/!/#ksc_icu/view/head/ON-PE_ICU_KMMG_20-26/06_M/01_SOURCE/Configuration/ECU/Mcal
#file 불러오기
# target_path = FEE_TARGET_PATH + 'Ecud_Fee.arxml'        #원본
target_path = NvM_TARGET_PATH + 'Ecud_NvM.arxml'        #원본
targetXML = open(target_path, 'rt', encoding='UTF8')

# 네임스페이스 너무 어려움...나중에 다시...
ET.register_namespace('',"http://autosar.org/schema/r4.0")
ET.register_namespace('xsi',"http://www.w3.org/2001/XMLSchema-instance")
#ET.register_namespace('schemaLocation',"http://autosar.org/schema/r4.0")
ns = {
    '':"http://autosar.org/schema/r4.0",
    'xsi':"http://www.w3.org/2001/XMLSchema-instance",
    #'schemaLocation':"http://autosar.org/schema/r4.0 autosar_4-3-0.xsd"
}

tree = ET.parse(targetXML)
root = tree.getroot()

targetChildForExtracting = root.findall("{http://autosar.org/schema/r4.0}AR-PACKAGES/"
                           "{http://autosar.org/schema/r4.0}AR-PACKAGE/"
                           "{http://autosar.org/schema/r4.0}ELEMENTS/"
                           "{http://autosar.org/schema/r4.0}ECUC-MODULE-CONFIGURATION-VALUES/"
                           "{http://autosar.org/schema/r4.0}CONTAINERS/"                                        
                           "{http://autosar.org/schema/r4.0}ECUC-CONTAINER-VALUE"
                           )

dictDemInform = {}
tempDemName = ''
tempDemLength = 0
for targetChilds in targetChildForExtracting:
    # print(targetChilds.find('{http://autosar.org/schema/r4.0}SHORT-NAME').text)
    mVariableShortName = targetChilds.find('{http://autosar.org/schema/r4.0}SHORT-NAME').text
    subChild = targetChilds.findall('{http://autosar.org/schema/r4.0}PARAMETER-VALUES')
    for targetChilds in subChild:
        # print('=' * 50)
        existDemNameFlag = False
        existDemLengthFlag = False
        for targetChild in targetChilds:
            # print(targetChild[0].text)
            if targetChild[0].text == '/AUTRON/NvM/NvMBlockDescriptor/NvMNvBlockLength':
                existDemLengthFlag = True
                # print(targetChild[1].text)
                # mVariableSize.append(targetChild[1].text)
                tempDemLength = targetChild[1].text
            if targetChild[0].text == '/AUTRON/NvM/NvMBlockDescriptor/NvMRamBlockDataAddress':
                existDemNameFlag = True
                # print(targetChild[1].text)
                # mVariableSize.append(targetChild[1].text)
                tempDemName = targetChild[1].text
            if existDemNameFlag == True and existDemLengthFlag == True:
                dictDemInform[tempDemName] = tempDemLength
                break
# print(dictDemInform.keys())
# print(dictDemInform.values())
# for dictValue in dictDemInform:
#     print(dictValue + "\t\t:\t\t" + dictDemInform[dictValue])
# exit()

###########################
#    코드 레벨에서 변수 선언 확인
###########################
listForSearch = ["O_LampLoadIPS",
"O_ShortTermLoadLatchRelay",
"O_LongTermLoadLatchRelay"
]
for val in listForSearch:
    print(val)
listForSearchKeysName = listForSearch
#=====================사용하나 임시로 주석처러(테스트 속도)===============
#p = re.compile('.+_Write\(uint')
# 원하는 함수에 대한 Filter
# 1. NvM Write 함수를 추출하기 위한 필터
p = []
if regularExEnableFlag == True:
    # p[0] = re.compile('.+_Write\(uint')
    # p[1] = re.compile('.+_Write\(uint')
    # 원하는 단어를 검색하기 위한 필터 생성
    for mVariablesBlockName in listForSearchKeysName:
        # p.append(re.compile('^u.+' + mVariablesBlockName + '.+;'))
        p.append(re.compile('.+' + mVariablesBlockName + '.+;', re.I))
    # print(p.index(re.compile('.+A_IGN2.+;')))
    # exit()
else:
    for mVariablesBlockName in listForSearchKeysName:
        # p.append(re.compile('^u.+' + mVariablesBlockName + '.+;'))
        p.append(mVariablesBlockName)
tempExtractTxt = ''
# exit()

for path, dirs, files in os.walk(TARGET_PATH):
    #print(path, files)     # 전체 파일 패스와 파일이름 출력
    if len(files) == 0:
        print("파일 없음")
    else:
        for file in files:
            if ((file.endswith('.c')or(file.endswith('.h')and(onlyCCodeFlag == False)))):     #확장자가 '.c'인 파일만 추출
                # print(path + "\\" + file)
                #f = open(path + "\\" + file,'r', encoding='UTF-8')
                #f = open(path + "\\" + file, 'r', encoding='UTF-16')
                #f = open(path + "\\" + file, 'r', encoding='cp949')
                #f = open(path + "\\" + file, 'r', encoding='euc-kr')
                #f = open(path + "\\" + file, 'r')
                #print(f.readlines())

                try:
                    f = open(path + "\\" + file, 'r', encoding='cp949')
                    testDefinitionFind(f,tempExtractTxt, p, listForSearch, regularExEnableFlag, caseSensitiveFlag)
                    # for line in f.readlines():
                    #     if findFlag == 0:
                    #         tempLine = line.lstrip()
                    #         if (tempLine.find('/*') == 0) and (tempLine.find('*/') >= 0):       # 주석 시작과 끝이 있을 경우
                    #             continue                    #실행 건너 띄기
                    #         if tempLine.find('/*') == 0:       # 주석 시작 부분이 있다면...
                    #             commentStartFlag = 1
                    #             continue                    #실행 건너 띄기
                    #         if line.find('*/') != -1:       # 주석 끝 부분이 있다면...
                    #             commentStartFlag = 0
                    #             continue                    #실행 건너 띄기
                    #         if (tempLine.find('//') == 0) or (tempLine.find('*') == 0) or (commentStartFlag == 1):
                    #             continue
                    #     if findFlag == 0:
                    #         if (p[0].match(line) != None or p[1].match(line) != None or p[2].match(line) != None) and line.find(';') == -1:
                    #             print(line)            # 라인 출력
                    #             tempTxt = tempTxt + line
                    #             findFlag = 1
                    #         if '{' in line:
                    #             blockCount = blockCount + 1
                    #         if '}' in line:
                    #             blockCount = blockCount - 1
                    #             if blockCount == 0:
                    #                 findFlag = 0
                    #     elif findFlag == 1:
                    #         if '{' in line:
                    #             blockCount = blockCount + 1
                    #         if '}' in line:
                    #             blockCount = blockCount - 1
                    #             if blockCount == 0:
                    #                 findFlag = 0
                    #         tempTxt = tempTxt + line
                    #         print(line)
                        #tempTxt = tempTxt + line.encode('cp949')
                        #tempTxt = tempTxt + line.encode('UTF-8')
                        #tempTxt = tempTxt + line.encode('ASCII')
                except:
                    f = open(path + "\\" + file, 'r', encoding='UTF-8')
                    testDefinitionFind(f,tempExtractTxt, p, listForSearch, regularExEnableFlag, caseSensitiveFlag)
                    # for line in f.readlines():
                    #     if findFlag == 0:
                    #         tempLine = line.lstrip()
                    #         if (tempLine.find('/*') == 0) and (tempLine.find('*/') >= 0):       # 주석 시작과 끝이 있을 경우
                    #             continue                    #실행 건너 띄기
                    #         if tempLine.find('/*') == 0:       # 주석 시작 부분이 있다면...
                    #             commentStartFlag = 1
                    #             continue                    #실행 건너 띄기
                    #         if line.find('*/') != -1:       # 주석 끝 부분이 있다면...
                    #             commentStartFlag = 0
                    #             continue                    #실행 건너 띄기
                    #         if (tempLine.find('//') == 0) or (tempLine.find('*') == 0) or (commentStartFlag == 1):
                    #             continue
                    #     if findFlag == 0:
                    #         if (p[0].match(line) != None or p[1].match(line) != None or p[2].match(line) != None) and line.find(';') == -1:
                    #             print(line)            # 라인 출력
                    #             tempTxt = tempTxt + line
                    #             findFlag = 1
                    #         if '{' in line:
                    #             blockCount = blockCount + 1
                    #         if '}' in line:
                    #             blockCount = blockCount - 1
                    #             if blockCount == 0:
                    #                 findFlag = 0
                    #     elif findFlag == 1:
                    #         if '{' in line:
                    #             blockCount = blockCount + 1
                    #         if '}' in line:
                    #             blockCount = blockCount - 1
                    #             if blockCount == 0:
                    #                 findFlag = 0
                    #         tempTxt = tempTxt + line
                    #         print(line)
                # for line in f.lines():
print(listForSearch)
exit()
#=====================================================================
resultTxt = tempExtractTxt
ff = open("d://testtest.txt",'w', encoding = 'UTF-8')
#ff = open("d://testtest.txt",'w')          # encoding 안했을 경우 에러 발생

ff.write(resultTxt)
f.close()
ff.close()

def ExcelLoad(spec, Info):
    filename = os.getcwd() + '\\' + Info.In_Folder + '\\' + spec
    xlApp = Dispatch("Excel.Application")
    xlWb = xlApp.Workbooks.Open(filename)
    sheet = xlWb.Sheets('DTC List')
    data = sheet.Range("A1").CurrentRegion
    data = data.Value
    data = listit(data)
    xlWb.Close(True)
    xlApp.Quit()

    for temprow in data:
        for idx, val in enumerate(temprow):
            if type(val) is float:
                temprow[idx] = unicode(int(val))

    row1 = data[1];
    fieldBuffer = []
    for index, temp in enumerate(row1):
        if row1[index]:
            row1V = row1[index]
            row1V = re.sub(r'\s+', "_", row1V)
            fieldBuffer.append(row1V)
    print
    fieldBuffer
    excelData = pd.DataFrame(data[2:], columns=fieldBuffer)
    try:
        excelData['Descript'] = excelData['Descript'].replace('\s+', '', regex=True)
    except:
        excelData['Descript'] = excelData['DTC']
    return excelData

def Search_Excelfile(path):
    file_list = os.listdir(path)
    Excel_list = []

    print
    'Excel File List :'
    for file in file_list:
        if '.xls' in file or '.xlsx' in file:
            Excel_list.append(file)
            print
            file

    return Excel_list[0]
